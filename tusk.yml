interpreter: bash -c
name: blockbench
options:

  launchdir:
    # treat this as private
    usage: >
      Don't set this option. Its a work around for a go-tusk peculiarity
    environment: PWD

  config:
    usage: >
      Base filename of the config file to use in configdir. Enables alternate
      configs for the same network.
    default:
      bench.json
  configshow:
    usage: "Report which, if any, supported configdir config file VAR's"
    type: bool

  gethimage:
    usage: >
      Image name to use for geth. (prioritised over bench.json)

  # private vars
  thistusk:
    private: true
    usage: "so this tusk file can refer to its own file name for recursive execution"
    default:
      command: echo $(pwd)/tusk.yml

  configvars:
    private: true
    usage: >
      The list of config VARS supported by most tasks. Use --configshow
      for any command to get the definite list.
    default: "name nodesdir maxnodes image genesis quorum_src geth_image delve_image pyenv"

tasks:

  raft:
    usage: >
      Configure a new raft network
    options:
      name:
        usage: >
          The name for the configuration defaults to "raft{maxnodes}"
        default: ""

      maxnodes:
        default: 5
        short: "n"

      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"

      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"

      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        default:
          command: echo "${launchdir}/quorum"

      gastarget:
        usage: "sets the --miner.gastarget option for the nodes"
        default: "18200000"

      gaslimit:
        usage: "sets the --miner.gaslimit option for the nodes"
        default: "18200000"

      recommit:
        usage: "sets the --miner.recommit option for the nodes."
        default: "2s"

    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - task:
          name: raftcfg
          options:
            name: "${name}"
            geth_image: ${geth_image}
            delve_image: ${delve_image}
            maxnodes: ${maxnodes}
            quorum_src: ${quorum_src}
          args:
            - ${configdir}
      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: gethgen
          args:
            - ${configdir}
      - task:
          name: raftstatic
          args:
            - ${configdir}
      - task:
          name: raftcompose
          options:
            gastarget: "${gastarget}"
            gaslimit: "${gaslimit}"
            recommit: "${recommit}"
          args:
            - ${configdir}

  rrr:
    usage: >
      Configure a new docker compose based rrr network
      # This task also ilustrates the full sequence of steps to prepare an rrr
      # compose setup
    options:
      name:
        usage: >
          The name for the configuration defaults to "rrr{maxnodes}"
        default: ""

      maxnodes:
        default: 17

      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"
      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"

      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        default:
          command: echo "${launchdir}/quorum"
      rrr_src:
        default:
          command: echo "${launchdir}/go-rrr"

      gastarget:
        usage: "sets the --miner.gastarget option for the nodes"
        default: "18200000"

      gaslimit:
        usage: "sets the --miner.gaslimit option for the nodes"
        default: "18200000"

      recommit:
        usage: "sets the --miner.recommit option for the nodes."
        default: "2s"

      maxnodes:
        usage: "the total number of nodes for the network"
        default: 17

    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - task:
          name: rrrcfg
          options:
            name: ${name}
            geth_image: ${geth_image}
            delve_image: ${delve_image}
            maxnodes: ${maxnodes}
            quorum_src: ${quorum_src}
            rrr_src: ${rrr_src}
          args:
            - ${configdir}
      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: rrralpha
          args:
            - ${configdir}
      - task:
          name: rrrgen
          args:
            - ${configdir}
      - task:
          name: rrrcompose
          options:
            gastarget: "${gastarget}"
            gaslimit: "${gaslimit}"
            recommit: "${recommit}"
          args:
            - ${configdir}

  configure:
    usage: >
      Put the rune for reading the config file into an environment variable so
      that it can be more readily re-used.  This one horror pays for a lot of
      simplicity elsewhere. The double cd trick combines the launchdir captured
      before tusk changes directory to the task file and then combines it with
      the cli choice of current directory. So that the cli choice remains
      relative to the launchdir.  Then we suck out the top level fields in the
      json config directory and expose them in a bash friendly format. This
      enables both shell tusk tasks and python to share the same config,
      without having to duplicate a bunch of stuff.
    private: true
    args:
      configdir:
    run:
      # execute these fragments in the task like this:
      #   CONFIGVARS="${configvars} extra_config_var1 extra_config_var2"
      #   eval ${READ_CONFIG}
      #   if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
      set-environment: {
        READ_CONFIG: "\
          $(cd ${launchdir} && cd ${configdir} \
          && python3 -c \"import json; \
                          [print(f'export {k}=\"{v}\"') \
                              for k, v in json.load(open('${config}')).items()]\")",
        SHOW_CONFIG: "for v in ${CONFIGVARS}; do echo $v=${!v}; done"}

  gethgendoc:
    include: tuskfiles/gethgendoc.yml

  gethkeys:
    include: tuskfiles/gethkeys.yml

  raftstatic:
    include: tuskfiles/raftstatic.yml

  raftcompose:
    include: tuskfiles/raftcompose.yml

  raftcfg:
    include: tuskfiles/raftcfg.yml

  gethgen:
    include: tuskfiles/gethgen.yml

  # rrr consensus commands
  rrrcfg:
    include: tuskfiles/rrrcfg.yml

  rrrgen:
    include: tuskfiles/rrrgen.yml

  # rrr support commands
  rrrcompose:
    include: tuskfiles/rrrcompose.yml

  rrralpha:
    include: tuskfiles/rrralpha.yml

  rrrextra:
    include: tuskfiles/rrrextra.yml

  # jupyter reporting
  jpycfg:
    include: tuskfiles/jpycfg.yml

  jpyrender:
    include: tuskfiles/jpyrender.yml

  tonb:
    usage: "convert the markdown notebook to ipython notebook format"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate
            cat standard-plots.md | jupytext --from .md --to notebook --output standard-plots.ipynb

  tomd:
    usage: "convert the ipython notebook format back to markdown"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate
            cat standard-plots.md | jupytext --from .md --to notebook --output standard-plots.ipynb

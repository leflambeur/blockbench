interpreter: bash -c
name: blockbench
options:

  launchdir:
    # treat this as private
    usage: >
      Don't set this option. Its a work around for a go-tusk peculiarity
    environment: PWD

  config:
    usage: >
      Base filename of the config file to use in configdir. Enables alternate
      configs for the same network.
    default:
      bench.json
  configshow:
    usage: "Report which, if any, supported configdir config file VAR's"
    type: bool

  gethimage:
    usage: >
      Image name to use for geth. (prioritised over bench.json)

  # private vars
  thistusk:
    private: true
    usage: "so this tusk file can refer to its own file name for recursive execution"
    default:
      command: echo $(pwd)/tusk.yml

  configvars:
    private: true
    usage: >
      The list of config VARS supported by most tasks. Use --configshow
      for any command to get the definite list.
    default: "nodesdir maxnodes image genesis quorum_src geth_image delve_image pyenv"

tasks:

  raft:
    usage: >
      Configure a new raft network
    options:
      maxnodes:
        default: 5
        short: "n"

      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"
      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"

      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        default:
          command: echo "${launchdir}/quorum"

    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - task:
          name: raftcfg
          options:
            geth_image: ${geth_image}
            delve_image: ${delve_image}
            maxnodes: ${maxnodes}
            quorum_src: ${quorum_src}
          args:
            - ${configdir}
      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: raftstatic
          args:
            - ${configdir}
      - task:
          name: gethgen
          args:
            - ${configdir}
      - task:
          name: raftcompose
          args:
            - ${configdir}

  rrr:
    usage: >
      Configure a new docker compose based rrr network
      # This task also ilustrates the full sequence of steps to prepare an rrr
      # compose setup
    options:
      maxnodes:
        default: 17

      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"
      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"

      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        default:
          command: echo "${launchdir}/quorum"
      rrr_src:
        default:
          command: echo "${launchdir}/go-rrr"

      maxnodes:
        usage: "the total number of nodes for the network"
        default: 17

    args:
      configdir:
        usage: Directory to put the network in
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - task:
          name: rrrcfg
          options:
            geth_image: ${geth_image}
            delve_image: ${delve_image}
            maxnodes: ${maxnodes}
            quorum_src: ${quorum_src}
            rrr_src: ${rrr_src}
          args:
            - ${configdir}
      - task:
          name: gethkeys
          args:
            - ${configdir}
      - task:
          name: rrralpha
          args:
            - ${configdir}
      - task:
          name: rrrgen
          args:
            - ${configdir}
      - task:
          name: rrrcompose
          args:
            - ${configdir}

  configure:
    usage: >
      Put the rune for reading the config file into an environment variable so
      that it can be more readily re-used.  This one horror pays for a lot of
      simplicity elsewhere. The double cd trick combines the launchdir captured
      before tusk changes directory to the task file and then combines it with
      the cli choice of current directory. So that the cli choice remains
      relative to the launchdir.  Then we suck out the top level fields in the
      json config directory and expose them in a bash friendly format. This
      enables both shell tusk tasks and python to share the same config,
      without having to duplicate a bunch of stuff.
    private: true
    args:
      configdir:
    run:
      # execute these fragments in the task like this:
      #   CONFIGVARS="${configvars} extra_config_var1 extra_config_var2"
      #   eval ${READ_CONFIG}
      #   if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
      set-environment: {
        READ_CONFIG: "\
          $(cd ${launchdir} && cd ${configdir} \
          && python3 -c \"import json; \
                          [print(f'export {k}=\"{v}\"') \
                              for k, v in json.load(open('${config}')).items()]\")",
        SHOW_CONFIG: "for v in ${CONFIGVARS}; do echo $v=${!v}; done"}

  gethgendoc:
    usage: render the template gensis document refered to by the configuration
    options:
      extra:
        usage: "extraData for the genesis doc"
        default: ""
    args:
      configdir:
        usage: >
          The config root directory.

    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            EXTRADATA=""
            [ -n "${gendoc_extra}" ] && EXTRADATA="${gendoc_extra}"
            [ -n "${extra}" ] && EXTRADATA="${extra}"
            export EXTRADATA

            cat <<PYEND | python3
            import os, json
            from pathlib import Path

            templatefile = Path(os.environ["genesis"]).resolve()

            o = json.load(open(templatefile))
            try:
                del o["alloc"]["0x0000000000000000000000000000000000000000"]
            except KeyError:
                pass
            o["alloc"][os.environ["gendoc_wallet"]] = dict(balance="${gendoc_balance}")

            extraData = os.environ["EXTRADATA"]
            if not extraData.startswith("0x"):
                extraData = "0x" + extraData
            o["extraData"] = extraData
            print(json.dumps(o, indent=2, sort_keys=True))
            PYEND

  gethkeys:
    usage: "regenerate all node keys and wallets"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate

            # Use the address of node0's node key as the genesis account (which
            # gets the gendoc_balance)
            source ${pyenv}/bin/activate

            cat <<PYEND | python3
            import os, json, coincurve
            from pathlib import Path

            for i in range(int(os.environ['maxnodes'])):

                dirname = f"{os.environ['nodesdir']}/node{i}"

                Path(dirname).mkdir(parents=True, exist_ok=True)

                # delete the keys first so we don't ever end up in a weird state
                for fn in ("key", "enode"):
                    try:
                        os.remove(f"{dirname}/{fn}")
                    except OSError:
                      pass

                p = coincurve.PrivateKey()
                key = p.to_hex()

                x, y = p.public_key.point()
                x = x.to_bytes(length=256//8, byteorder="big").hex()
                y = y.to_bytes(length=256//8, byteorder="big").hex()
                enode = x + y

                for fn in ("key", "enode"):
                    with open(Path(f"{dirname}/{fn}"), "w") as f:
                        f.write(locals()[fn])
                        print(f"Wrote {dirname}/{fn}")

            # Now make node0 the genesis wallet
            keyfile = f"{os.environ['nodesdir']}/node0/key"
            pub = None
            with open(Path(keyfile)) as f:
                key = coincurve.PrivateKey.from_hex(f.read())
                pub = key.public_key.format(compressed=False)[1:]
            addr = pub[-20:]

            j = None
            with open("bench.json") as f:
                j = json.load(f)
            j["gendoc_wallet"] = addr.hex()
            j["bootnode0"] = pub.hex()
            print(f"Wrote bootnode0: {pub.hex()}")
            with open("bench.json", "w") as f:
                json.dump(j, f, indent=2, sort_keys=True)
            PYEND
            echo "gethkeys: done"
            cat bench.json
            echo "updated gendoc_wallet: done"


            cat <<END > bootnodes.env
            BOOTNODE0_PUB=$(cat ${nodesdir}/node0/enode)
            END
            cat bootnodes.env
            echo "Updated bootnode.env for docker-compose"

            if [ -f env.env ]; then
              cat env.env bootnodes.env > .env
              cat .env
              echo "Updated .env for docker-compose"
            fi

  raftstatic:
    usage: "make static-nodes.json for all the raft nodes"
    options:
      last:
        usage: >
          Set to the last node index to include (0 means all which is the default)
        default: "0"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            end=${last}
            [ "${end}" == "0" ] && end=$((maxnodes -1))
            export end
            echo "raftstatic: end=$end"

            source ${pyenv}/bin/activate

            cat <<PYEND | python3
            import os, json, coincurve, sha3, secrets, pathlib

            static=[]

            p2port="7200"
            raftport="50000"

            for i in range(int(os.environ['end']) + 1):

                dirname = f"{os.environ['nodesdir']}/node{i}"

                enode = open(f"{dirname}/enode", 'r').read()

                static.append(
                  f"enode://{enode}@node{i}:{p2port}?discport=0&raftport={raftport}"
                )

            # now go round again and put a full copy in the right directory
            for i in range(int(os.environ['end']) + 1):
                datadir = f"{os.environ['nodesdir']}/node{i}/data"
                pathlib.Path(datadir).mkdir(parents=True, exist_ok=True)
                with open(pathlib.Path(datadir).joinpath("static-nodes.json"), "w") as f:
                    json.dump(static, f, indent=2, sort_keys=True)
                    f.flush()
                    print(f"Wrote: {datadir}/static-nodes.json")
                    print(json.loads(open(f"{datadir}/static-nodes.json").read()))
            PYEND


  raftcompose:
    usage: "make a docker-compose for a geth network from a base.yml and a node.yml"

    options:
      compose_project:
        default: "raft"
      networkid:
        default: "53456"
      netrestrict:
        # Use a different CIDR for each consensus type please. just bump the
        # 3rd digit
        default: 172.19.1.10/24

    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            CONFIGVARS="${configvars} compose_project networkid netrestrict raft_blocktime"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}
            CONFIGDIR=$(pwd)

            cat <<END > .env
            COMPOSE_PROJECT_NAME=raft
            RAFT_CONSENSUS_OPTS="\
            --raft --raftport 50000 --raftdnsenable --raftblocktime ${raft_blocktime}"
            NETWORKID=${networkid}
            NETRESTRICT=${netrestrict}
            ETHERBASE=${gendoc_wallet}
            QUORUM_SRC=${quorum_src}
            NODESDIR=${nodesdir}
            GETH_IMAGE= ${geth_image}
            DELVE_IMAGE=${delve_image}
            END
            echo "Wrote .env"

            # Merge in the appropriate number of copies of node.yml to the
            # docker-compose.yml we are generating. As we do that add the
            # numeric suffices to each nodes service entry and the working_dir
            # it uses
            cp ${TUSKDIR}/compose/raft/base.yml .
            cp ${TUSKDIR}/compose/raft/node.yml .
            cp base.yml docker-compose.yml

            # each document fragment has to be valid. so they all need the
            # x-node-defaults anchor to be defined.
            cat <<END > tmp.yml
            x-node-defaults:
              &node-defaults
            END

            PORT=8300
            for i in $(seq 0 $((${maxnodes} - 1)))
            do
                VAL=$i EXPOSED="\"${PORT}:\"" yq eval '
                  .node |= .working_dir += env(VAL) |
                  del(.x-node-defaults) |
                  .node.ports[0] |= . = env(EXPOSED) + . |
                  with_entries(.key |= .  + env(VAL))
                ' node.yml
                PORT=$((PORT + 1))
            done >> tmp.yml
            yq eval-all --inplace '
                select(fileIndex == 0) * {"services": select(fileIndex == 1)}
                | del(.services.x-node-defaults)' docker-compose.yml tmp.yml
            echo "Wrote docker-compose.yml"


  raftcfg:
    usage: "inititialise for geth (no particular consensus)."
    args:
      configdir:
        usage: >
          The config root directory.
    options:

      nodesdir:
        usage: "relative to configdir. each node gets a subdirectory here named node{N}"
        default: nodes
      maxnodes:
        usage: "the total number of nodes for the network"
        default: 5
      genesis:
        default: "genesis-in.json"
      gendoc_balance:
        default: "1000000000000000000000000000"
      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"
      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"
      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        # TODO: adjust the compose file so this can be ../../quorum
        default:
          command: echo "${launchdir}/quorum"

      raft_blocktime:
        usage: |
          the --raftblocktime cosensus parameter for starting geth (ms)
        default: 50

    run:
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            cd ${launchdir} && mkdir -p ${configdir} && cd ${configdir}
            mkdir -p ${nodesdir}/node0


            # we don't allow this to be set on the cli, if you want another
            # env thats fine, just edit bench.json afterwords to point to yours
            # and make sure you install the requirements.txt
            pyenv="env"

            echo "Initialising in: $(pwd)"

            python3 -m venv ${pyenv}
            source ${pyenv}/bin/activate
            pip3 install -r ${TUSKDIR}/requirements.txt

            # generate the config from the options
            cat <<JEND  > bench.json
            {
              "pyenv": "${pyenv}",
              "maxnodes": "${maxnodes}",
              "nodesdir": "$(pwd)/${nodesdir}",
              "quorum_src": "${quorum_src}",
              "geth_image": "${geth_image}",
              "delve_image": "${delve_image}",
              "genesis": "${genesis}",
              "gendoc_balance": "${gendoc_balance}",
              "raft_blocktime": "${raft_blocktime}"
            }
            JEND

            cat bench.json
            echo "Wrote: $(pwd)/bench.json"

  gethgen:
    usage: "rrr genesis - keeps existing keys and alpha contributions"
    options:
      sudo:
        type: bool
      genesisfor:
        default: raft
      extradata:
        default: ""

    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            CONFIGVARS="${configvars} gendoc_extra"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            EXTRADATA="${extradata}"
            [ -n "${EXTRADATA}" ] && EXTRADATA=${gendoc_extra}
            [ -n "${EXTRADATA}" ] && EXTRADATA=""


            CONFIGDIR=$(pwd)

            cp ${TUSKDIR}/compose/${genesisfor}/genesis-in.json .

            pushd ${launchdir} # restore launchdir before recursive invoke
              tusk -qf ${thistusk} gethgendoc ${configdir} --extra "$EXTRADATA" | tee ${CONFIGDIR}/genesis.json
            popd

            # clear out all the data dirs first to avoid mixed state if we fail
            # half way through
            ${sudo} && dosudo="sudo" || dosudo=""

            end=$((maxnodes - 1))
            for i in $(seq 0 ${end}); do
              ${dosudo} rm -rf ${nodesdir}/node$i/data
            done

            for i in $(seq 0 ${end}); do
              rm -rf ${nodesdir}/node$i/data
            done

            genesis_doc=$(pwd)/genesis.json
            for i in $(seq 0 ${end}); do
              geth="docker run --rm -u $(id -u):$(id -g) -v $(pwd):$(pwd) ${geth_image} --nousb"
              ${geth} \
                  --datadir=$(pwd)/nodes/node${i}/data  \
                  --nodekey $(pwd)/nodes/node${i}/key \
                  init $(pwd)/genesis.json
            done

  # rrr consensus commands
  rrrcfg:
    usage: "inititialise for rrr consensus network"
    args:
      configdir:
        usage: >
          The config root directory.
    options:
      numcandidates:
        short: c
        usage: "set the number of canidate leaders per round"
        default: 2
      numendorsers:
        short: e
        usage: "set the size of the endorser committee"
        default: 7
      committeequorum:
        short: q
        default: 4
      activehorizon:
        usage: >
          number of blocks to allow for activity. Any identities without
          endorsements or blocks in this number of blocks is droped. (and will
          have to re-enrol).
        short: a
        default: 2000
      intentphase:
        usage: number of miliseconds for the rrr intent phase
        default: 1500
      confirmphase:
        usage: number of milliseconds for the rrr confirm phase
        default: 1500
      roundlength:
        usage: >
          total roundlength in milliseconds. must be greater than intent + confirm (rember to
          allow for block disemination, 2s  or more is fair)
        default: 5000

      nodesdir:
        usage: "relative to configdir. each node gets a subdirectory here named node{N}"
        default: nodes
      maxnodes:
        usage: "the total number of nodes for the network"
        default: 17
      genesis:
        default: "genesis-in.json"
      gendoc_balance:
        default: "1000000000000000000000000000"
      geth_image:
        usage: "the docker image to use for geth-rrr"
        default: "eu.gcr.io/fetlar-1/geth-rrr:fetlar-latest"
      delve_image:
        usage: "the docker image to use for running geth-rrr in for remote debug"
        default: "eu.gcr.io/fetlar-1/rrr-delve:fetlar-latest"
      quorum_src:
        usage: |
            the host directory to be mounted as /go/src/quorum. must contain quorum clone.
            only required if you need to interactively debug the node.
        # TODO: adjust the compose file so this can be ../../quorum
        default:
          command: echo "${launchdir}/quorum"
      rrr_src:
        default:
          command: echo "${launchdir}/go-rrr"

    run:
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            cd ${launchdir} && mkdir -p ${configdir} && cd ${configdir}
            mkdir -p ${nodesdir}/node0


            # we don't allow this to be set on the cli, if you want another
            # env thats fine, just edit bench.json afterwords to point to yours
            # and make sure you install the requirements.txt
            pyenv="env"

            echo "Initialising in: $(pwd)"

            python3 -m venv ${pyenv}
            source ${pyenv}/bin/activate
            pip3 install -r ${TUSKDIR}/requirements.txt

            # generate the config from the options
            cat <<JEND  > bench.json
            {
              "pyenv": "${pyenv}",
              "maxnodes": "${maxnodes}",
              "nodesdir": "$(pwd)/${nodesdir}",
              "quorum_src": "${quorum_src}",
              "geth_image": "${geth_image}",
              "delve_image": "${delve_image}",
              "rrr_src": "${rrr_src}",
              "genesis": "${genesis}",
              "gendoc_balance": "${gendoc_balance}",
              "numcandidates": "${numcandidates}",
              "numendorsers": "${numendorsers}",
              "committeequorum": "${committeequorum}",
              "activehorizon": "${activehorizon}",
              "intentphase": "${intentphase}",
              "confirmphase": "${confirmphase}",
              "roundlength": "${roundlength}"
            }
            JEND

            cat bench.json
            echo "Wrote: $(pwd)/bench.json"


  # rrr - genesis
  rrrgen:
    usage: "rrr genesis - keeps existing keys and alpha contributions"
    options:
      sudo:
        type: bool
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            CONFIGVARS="${configvars}"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            CONFIGDIR=$(pwd)

            cp ${TUSKDIR}/compose/rrr/genesis-in.json .

            pushd ${launchdir} # restore launchdir before recursive invoke

              EXTRADATA=$(tusk -qf ${thistusk} rrrextra ${configdir})
              tusk -qf ${thistusk} gethgendoc ${configdir} --extra $EXTRADATA | tee ${CONFIGDIR}/genesis.json

            popd

            # clear out all the data dirs first to avoid mixed state if we fail
            # half way through
            ${sudo} && dosudo="sudo" || dosudo=""

            end=$((maxnodes - 1))
            for i in $(seq 0 ${end}); do
              ${dosudo} rm -rf ${nodesdir}/node$i/data
            done

            for i in $(seq 0 ${end}); do
              rm -rf ${nodesdir}/node$i/data
            done

            genesis_doc=$(pwd)/genesis.json
            for i in $(seq 0 ${end}); do
              geth="docker run --rm -u $(id -u):$(id -g) -v $(pwd):$(pwd) ${geth_image} --nousb"
              ${geth} \
                  --datadir=$(pwd)/nodes/node${i}/data  \
                  --nodekey $(pwd)/nodes/node${i}/key \
                  init $(pwd)/genesis.json
            done



  # rrr support commands
  rrrcompose:
    usage: |
      Generate a docker compose configuration for running rrr
    options:
      compose_project:
        default: "rrr"
      networkid:
        default: "53456"
      netrestrict:
        default: 172.19.0.10/24
    args:
      configdir:
        usage: >
          The config root directory.

    run:
      - task:
          name: configure
          args:
            - ${configdir}
      - command:
          exec: |
            set -e

            TUSKDIR=$(pwd)

            CONFIGVARS="${configvars} rrr_src gendoc_extra gendoc_wallet gendoc_balance numcandidates numendorsers committeequorum intentphase confirmphase roundlength"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi

            cd ${launchdir} && cd ${configdir}

            cat <<END > env.env
            COMPOSE_PROJECT_NAME=${compose_project}
            RRR_CONSENSUS_OPTS="\
            --rrr.nc ${numcandidates} \
            --rrr.ne ${numendorsers} \
            --rrr.q ${committeequorum} \
            --rrr.ta ${activehorizon} \
            --rrr.intentphase ${intentphase} \
            --rrr.confirmphase ${confirmphase} \
            --rrr.roundlength ${roundlength}"
            NETWORKID=${networkid}
            NETRESTRICT=${netrestrict}
            ETHERBASE=${gendoc_wallet}
            QUORUM_SRC=${quorum_src}
            RRR_SRC=${rrr_src}
            NODESDIR=${nodesdir}
            GETH_IMAGE= ${geth_image}
            DELVE_IMAGE=${delve_image}
            END
            cat env.env
            echo "Wrote env.env"

            cat <<END > bootnodes.env
            BOOTNODE0_PUB=$(cat ${nodesdir}/node0/enode)
            END

            cat bootnodes.env
            echo "Wrote bootnodes.env"

            cat env.env bootnodes.env > .env
            cat .env
            echo "Wrote .env"

            # Merge in the appropriate number of copies of node.yml to the
            # docker-compose.yml we are generating. As we do that add the
            # numeric suffices to each nodes service entry and the working_dir
            # it uses
            cp ${TUSKDIR}/compose/rrr/base.yml .
            cp ${TUSKDIR}/compose/rrr/node.yml .
            cp base.yml docker-compose.yml

            # each document fragment has to be valid. so they all need the
            # x-node-defaults anchor to be defined.
            cat <<END > tmp.yml
            x-node-defaults:
              &node-defaults
            END

            PORT=8300
            for i in $(seq 0 $((${maxnodes} - 1)))
            do
                VAL=$i EXPOSED="\"${PORT}:\"" yq eval '
                  .node |= .working_dir += env(VAL) |
                  del(.x-node-defaults) |
                  .node.ports[0] |= . = env(EXPOSED) + . |
                  with_entries(.key |= .  + env(VAL))
                ' node.yml
                PORT=$((PORT + 1))
            done >> tmp.yml
            yq eval-all --inplace '
                select(fileIndex == 0) * {"services": select(fileIndex == 1)}
                | del(.services.x-node-defaults)' docker-compose.yml tmp.yml
            # yq eval-all --inplace 'select(fileIndex == 0) * {"services": select(fileIndex == 1)} | del(.services.x-node-defaults)' docker-compose.yml tmp.yml

  rrralpha:
    usage: "generate the rrr alpha.json docs required by rrrextra (for the genesis VRF seed)"
    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            source ${pyenv}/bin/activate
            cat <<PYEND | python3
            import os, coincurve, sha3, secrets, pathlib

            for i in range(int(os.environ['maxnodes'])):

                dirname = f"{os.environ['nodesdir']}/node{i}"

                key = open(f"{dirname}/key", 'r').read()
                key = coincurve.PrivateKey.from_hex(key)

                rawpub = coincurve.PublicKey.from_valid_secret(key.secret).format(compressed=False)
                nodeid = sha3.keccak_256(rawpub[1:]).digest()
                print(f"alpha[{i}] nodeid {nodeid.hex()}")

                # This nodes contribution to the genesis seed alpha
                alpha = secrets.token_bytes(32)
                sig = key.sign_recoverable(alpha, hasher=None)
                doc = f'{{"nodeid":"0x{nodeid.hex()}", "alpha": "0x{alpha.hex()}", "sig": "0x{sig.hex()}"}}'
                with open(pathlib.Path(f"{dirname}/alpha.json"), "w") as f:
                    f.write(doc)
                    print(f"Wrote: {dirname}/alpha.json")
            PYEND

  rrrextra:
    usage: "generate the extradata hex string for the rrr genesis document"
    options:
      showids:
        short: "i"
        type: bool

    args:
      configdir:
        usage: >
          The config root directory.
    run:
      - task:
          name: configure
          args:
            - ${configdir}

      - command:
          exec: |
            set -e
            CONFIGVARS="${configvars} gendoc_extra gendoc_wallet gendoc_balance"
            eval ${READ_CONFIG}
            if ${configshow}; then eval ${SHOW_CONFIG}; exit 0; fi
            cd ${launchdir} && cd ${configdir}

            # we cd to run the rrr tool, so these need to be absoloute
            nodesdir=$(cd ${nodesdir} && pwd)
            node0dir=${nodesdir}/node0

            SHOWIDS=""
            ${showids} && SHOWIDS="--showids"

            ALPHAS=""
            for n in $(seq 0 $((${maxnodes} - 1))); do
              ALPHAS="$ALPHAS ${nodesdir}/node${n}/alpha.json"
            done

            cd ${rrr_src}/tools

            go run cmd/rrrctl/main.go genextra \
                ${SHOWIDS} --datadir ${node0dir} $ALPHAS
